# 算法思路总结

## 数组

1. JavaScript并不限制数组的数据类型，因此数组**可以存放任意类型的数据**。
2. 当一个数组存放相同类型的数据时，数组在内存空间上是**连续存储**的。
3. JavaScript提供直接操作原数组来**删除数组元素**的方法，例如栈方法`pop()`、队列方法`shift()`、`splice()`方法等。
4. 数组的长度是动态变化的，即新增数据会自动增加。也可以通过减少数组长度来丢弃不需要的数据。

### 二分法

1. 面对**有序数组**的查找元素问题，通常可以考虑二分法。
2. 二分法的**基本思想**：把数组一分为二，把目标值和中间的那个元素进行比较，再不断缩小目标值的存在区间，最终当mid值等于目标值时，返回mid元素的下标。
3. 运用二分法的**关键**在于**确定循环区间的边界**：循环区间到底是左闭右开`[left, right)`，还是左闭右闭`[left, right]`？不同的边界情况下，对于**循环结束、区间变化的处理**都是不一样的。一旦确定好循环区间边界，接下来的逻辑都要跟着这个区间边界走。
4. 确定mid值时，仅仅写`(left + right) / 2`可能会出现**数字过大溢出**的情况（比如`left`和`right`都大于1/2的MAX_VALUE时，数字会溢出），可以采取更优化的写法`left + (right - left)/2`。

### 双指针法

双指针可以通过一个for循环来完成两个for循环**遍历数组**的工作，**降低时间复杂度**。

#### 快慢双指针

1. 面对**一些数组的筛选问题**时（比如删除重复项），可以考虑快慢双指针法。
2. 快指针和慢指针可以理解为一个排雷的过程，快指针在前面排雷，慢指针负责守护安全区。

#### 首尾双指针

1. 面对**一些数组的排序问题**时，可以考虑首尾双指针法。
2. 利用首尾元素的比较进行排序。

#### 滑动窗口

1. 滑动窗口法的本质还是双指针法，但是**滑动窗口得到的是数组的一个连续区间**。

2. 滑动窗口法的基本思想是**根据某个条件来不断改变数组的子序列**，就像一个在滑动的窗口一样。

3. 使用滑动窗口法的**关键**是要弄清楚：

   - 什么时候要扩大窗口（改变右指针）？

   
   - 什么时候要缩小窗口（改变左指针）？
   
   
   - 子序列改变时是否还要进行什么操作（根据需求而定）？

### 模拟行为

1. 给一个数组进行模拟成别的形式（例如矩阵），或者给出模拟后的形式，要求转化回数组。
2. 该类题目没有什么算法，最关键是要**确定好边界**。例如螺旋矩阵题目，就可以通过不断缩小上下左右四条边界来框定数组和矩阵的关系。边界关系一旦梳理清楚，代码就水到渠成了。



## 链表

1. 链表是一种**通过指针把各个节点串联在一起的线性数据结构**，链表的每个节点包括数据域和指针域，指针域存放着指向下一个节点的指针(`next`)。

2. **链表的节点在内存中并不是连续存储的，只是链表能通过指针把它们串联起来。**

   也正因为如此，对数据进行新增和删除的操作，和数组相比（时间复杂度为O(n)），链表的新增和删除效率更高，只要修改指针的指向即可完成（时间复杂度为O(1)）。

   与之相对的，链表的查询效率就不及数组了。

3. 链表有单链表和双链表，其中双链表的节点指针域不仅存放`next`，还存放了指向前一个结点的指针(`prev`)。

### 虚拟头节点

1. 涉及**对链表的节点进行操作**的问题（比如移除链表元素、删除倒数第n个节点、两两交换节点等等），通常要定义一个虚拟头节点。
2. 虚拟头节点的作用是**把头节点看成一个普通节点，免除了额外考虑头节点的情况**，更便于我们对节点进行操作。

### 双指针法

1. 链表中的双指针法通常指的是快慢指针法，涉及**需要对链表进行遍历再解决的问题**（比如反转链表、求链表的相交节点、环形链表问题等等），都可以考虑双指针。
2. 对于环形链表求环入口的问题，要考虑清楚两个指针的所走路程之间的关系、以及所走路程和所求未知量的关系。
