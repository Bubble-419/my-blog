# JavaScript面试基本功知识点总结-基础篇

## 数据类型

1. #### **JavaScript有哪些数据类型？**

   6种基本数据类型：`Undefined`, `Null`, `Boolean`, `String`, `Number`, `Symbol`；

   1种复杂数据类型：`Object`.

   

2. #### **原始值和引用值是什么？有什么区别？**

   变量有按值访问和按引用访问两种方式。

   当声明**基本数据类型**的变量并赋值时，变量里存储的值都是**原始值**，即我们**访问的是变量的实际值**。

   但是声明**对象**并对对象进行操作时，我们**访问的是对象的引用值**。因为JavaScript不允许访问对象的内存位置，所以我们只能访问对象的引用值而不是对象本身。

   **区别**：

   - **保存位置不同**：原始值保存在全局作用域的栈内存中，引用值实际上是一个指针，指向存储在堆内存的对象中。

   - **传递方式不同**：当进行变量复制的操作时，原始值会被复制一份副本赋给新变量，而引用值则是复制一个指向同一对象的指针再赋给新变量，内存中的对象不变。

     > 函数的参数传递规则等同于变量复制，即**参数传递是值传递的方式**。
     >
     > 因此对于引用值的值传递，就是传递一份复制的指针；而引用传递是直接传递原指针。

   

3. #### `undefined`和`null`的区别是什么？

   - **意义不同**：`undefined`是未初始化变量，`null`是对象空指针。

     当变量被声明却没有初始化时，会默认其值为`undefined`，而无需显式声明。

     但是当对象被声明，而当下还没有合适的变量值时，我们会选择给对象赋值为`null`。

   - 对未声明的变量和未初始化变量调用`typeof`时，得到的结果都是`undefined`，

     但是对空指针对象调用`typeof`时，得到的结果是`object`.
     
     

4. #### **不同类型与布尔值之间的转换规则是什么？**

   要弄清楚除了布尔型的`false`以外，其他数据类型还有哪些值是`falsy`的（假值）：

   | 数据类型  | falsy值        |
   | --------- | -------------- |
   | String    | “”（空字符串） |
   | Number    | **0**、NaN     |
   | Undefined | undefined      |
   | Object    | null           |

   > 控制流语句会自动进行其他数据类型和布尔型之间的转换。

   

5. #### **不同类型与数值类型之间的转换规则是什么？**

   首先要知道，不同类型转换为数值类型有三种方式**：`Number()`转型函数、`parseInt()`、`parseFloat()`.**

   **Number()可以处理任何数据类型**：

   | 数据类型  | 数值                                                         |
   | --------- | ------------------------------------------------------------ |
   | Undefined | 0                                                            |
   | Boolean   | true --> 1, false --> 0                                      |
   | String    | ①空字符串 --> 0；②包含数值字符（有效整数、浮点数、十六进制数） --> 十进制数值； ③其他字符串 --> NaN |
   | Object    | 先调用`valueOf()`，不是NaN --> 直接返回；是NaN --> 调用`toString()`，根据String的转换规则处理 |

   **后两个方法是针对`String`类型的**：

   从第一个非空格字符开始，依次检测每一个字符，直到遇见字符串结尾或者非数值字符。

   如“blue1234”会返回1234.

   二者区别：

   - `parse`方法遇到空字符串会返回NaN，而`Number()`会返回0；

   - `parse`方法可以解析十六进制。

     

6. #### **什么是`NaN`？如何判断？**

   `NaN`，即“Not a Number”，不是数字，但**是一个特殊的数值**。

   **原本要返回一个数值但是操作失败**时，返回值会是`NaN`。

   当我们需要判断某个值是否是`NaN`时，可以**使用`isNaN()`方法**：

   首先我们需要知道，`NaN`是一个数值，因此要判断某个值是否是`NaN`时，**第一步是进行数据类型的转换，第二步才是判断是否为`NaN`。**

   如果一个值可以转换为数值，则`isNaN()`会返回false，反之则true。



7. #### 基本数据类型中的`Symbol`有什么用？

   `Symbol`**值是唯一、不可变的值。**

   用处：

   - **可以作为对象独一无二的属性名**

     对象的属性名可以是字符串或者`Symbol`，凡是`Symbol`的属性名，都不会与其他属性产生冲突。

   - **可以用于定义对象非私有但仅用于内部的方法**

     本质上还是定义对象的唯一属性名，但是因为`Symbol`值作为对象的属性名时不会被常规方法遍历得到，所以可以用于定义仅用于内部的方法。

   注意点：

   - `Symbol`值没有包装类，直接使用`Symbol()`声明
   - `Symbol()`的参数仅用于对`Symbol`值的描述，不会影响`Symbol`值的唯一性
   - 如果需要复用`Symbol`值，需要在全局符号注册表中用`Symbol.for()`注册



8. #### 隐式的类型转换有哪些情况？

   - **四则运算符中的隐式转换**：

     - 加法操作中如果有一个操作数是字符串，就会把另一个操作数的类型转换为字符串
     - 其他操作中只要有一个操作数是数值，就会把另一个操作数转换为数值

   - **等于`(==)`和不等于`(!=)`操作符中的隐式转换**：

     等于和不等于操作符会在比较前进行类型转换（全等和不全等操作符不会强转类型）。

     - 有布尔，转数值

     - 字符和数值，转数值

     - `null`和 `undefined`，不能转，但是`null == undefined`

     - `NaN`不用转，和谁比都是不相等

     - 有一个是对象，调用`valueOf()`比较原始值

       两个都是对象，比较是否是同一个对象



## 数据类型判断

1. #### 类型判断有哪几种方式？

   - `typeof`操作符

     `typeof`通常用于**基本数据类型的判断**，因为原始值使用`typeof`来判断类型是很方便的，但是引用值使用`typeof`时，只会得到`function`或`object`的结果，并不能很直接的判断出引用值的类型。

     `typeof`操作符有几个注意点：

     （1） **不能判断`null`类型**。如果对`null`使用`typeof`，结果会是`object`，这是因为null的意义就是空指针对象。

     （2） `typeof`**操作符是未声明变量的唯一有效操作**，返回结果是`undefined`。

   - `instanceof`操作符

     `instanceof`通常用于**判断原型和实例之间的关系**，即通过原型链的方式来判断对象的类型。

     `instanceof`的原理是检测构造函数的`prototype`属性是否出现在实例对象的原型链上，具体原理见第二道题。

   - `Object.prototype.toString.call()`

     **能判断的方式最完整**。

     ```javascript
     console.log(Object.prototype.toString.call([])); // [object Array]
     ```

     但是要注意，这个方式没办法判断出实例对象和原型的关系。

     ```js
     /*
     父类SuperType 子类SubType
     let instance = new SubType();
     */
     
     console.log(Object.prototype.toString.call(instance)); // [object Object] 打印结果与父类无关
     console.log(instance instanceof SuperType); // true
     ```

   - ** `isXXX` 的API**

     **判断特定类型的API**，比如`isArray()`、`isNaN()`等。

     

2. #### `instanceof`操作符的原理是什么？

   首先要知道`instanceof`的语法是：`object instanceof constructor`，即 `instanceof`检测的是**实例对象和构造函数**二者的关系，再进一步讲，它**检测构造函数的`prototype`属性是否出现在实例对象的原型链上**。

   那么 `instanceof`是怎么知道`constructor`的原型对象有没有在`object`的原型链上出现过的呢？

   ```js
   // 模拟instanceof的查找过程
   function instance_of(obj, constructor){
     // 实例对象的原型链
     let obj_proto = obj.__proto__;
     // 构造函数的原型对象    
     let prototype = constructor.prototype;
       
     // 循环遍历obj的原型链
     while(obj_proto !== null){
       // 说明constructor的原型对象有出现在obj的原型链上，返回true
       if(obj_proto === prototype) return true;
       obj_proto = obj_proto.__proto__;
     }
       
     // obj_proto为null时仍未返回true，则说明找不到
     return false;
   }
   ```
   
   

## 对象

### `new`操作符

1. #### `new`操作符做了什么事？

   (1) 在内存中创建一个新对象

   (2) 将新对象的`__proto__`属性（实际上是`[[prototype]]`特性）指向构造函数`constructor`的`prototype`属性，即原型对象

   (3) 将构造函数的`this`指向新对象

   (4) 执行构造函数

   (5) 构造函数返回了一个非空对象 ? 该非空对象 : 新对象

   简单概括，`new`操作符会**调用构造函数，与原型对象链接，并返回一个对象**，达到**创建实例对象**的效果。

2. #### `new`操作符返回不同类型时有什么表现？

   从`new`操作符行为的第五步可以知道：

   当构造函数**没有显式定义返回值为某个对象**时，`new`操作符会**返回它第一步创建的那个新对象**；

   而一旦构造函数**有返回一个非空对象**，那么即使中间那几步仍然会正常进行，也不会返回我们想创建的新对象，而是**返回这个非空对象**。
   
   在调用类构造函数时，如果把类构造函数的返回对象修改成另一个非空对象，会导致类与实例对象通过`this`而产生的连接断掉，所以此时再对实例对象使用`instanceof`操作，也不会检测出和父类有关联。

### 原型

1. #### 谈谈你对原型的理解。

   - **原型其实就是原型对象**，原型对象中**包含了可以被对象实例共享的属性和方法**，其中最重要的属性就是`constructor`，其指向与原型对象关联的构造函数。
   - （原型有什么用？）当我们希望所有对象实例共享一些方法时，如果写在构造函数里，所有实例都要创建相同作用的函数，导致浪费内存；如果写在全局作用域里再由构造函数引用，又会导致污染全局作用域。这时候就可以考虑把需要共享的方法（或属性）写在原型对象里。
   - 原型对象的`constructor`属性指向与之关联的构造函数，而构造函数的`prototype`属性又会指向该原型对象，这二者是循环引用的关系。
   - 所有实例对象都可以通过`__proto__`指针找到原型对象，说明实例和原型之间是有显性关系的，而实例和构造函数之间却没有。所有对象的顶层原型对象都是`Object`（原型链中`Object`的原型是`null`)。

### 继承

1. #### JavaScript如何实现继承？

   - ##### **原型链继承**

     > **（1） 什么是原型链？**

     ​		实例对象的`__proto__`指针指向原型对象，那么如果实例对象的原型对象是另一个类的实例对象，就形成了链式关系。

     > **（2） 怎么利用原型链实现继承？**

     ```javascript
     // 父类构造函数
     function SuperType(superPro){
       this.superProperty = superPro;
     }
     
     // 父类原型对象上的方法
     SuperType.prototype.getSuperProperty = function() {
       return this.superProperty;
     }
     
     // 子类构造函数
     function SubType(subPro){
       this.subProperty = subPro;
     }
     
     // **把子类的原型对象重写为父类的一个实例对象，调用父类的构造函数，相当于把子类的原型对象修改为一个__proto__指针指向Supertype.prototype的对象
     SubType.prototype = new SuperType();
     
     // 子类原型对象上可以再定义自己的方法，也可以重写父类方法
     SubType.prototype.getSubProperty = function() {
       return this.subProperty;
     }
     ```

     > **（3） 需要注意的是：**

     ​	**子类实例对象的原型对象，实际上是父类的一个实例对象**。

     > **（4）原型链继承的缺点：**

     ​			对父类构造函数中定义的**引用值属性**的修改操作会造成多个子类实例对象属性值被污染（牵一发而动全身）；

     ​			子类在实例化时不能给父类的构造参数传参，因为子类实例化时无法访问到父类的构造函数。

     

   - ##### 经典继承（盗用构造函数）

     > **怎么实现？**
   
     **通过`call`或`apply`方法修改父类构造函数的执行上下文对象**，达到劫持构造函数的效果。
   
     ```javascript
     // 父类定义同上
     
     // 子类构造函数
     function SubType(subPro){
       // **利用call方法把当前对象作为上下文来执行父类构造函数，并传参
       SuperType.call(this, 'super');
       this.subProperty = subPro;
     }
     
     // 测试
     let instance = new SubType('sub');
     
     console.log('subPro:' + instance.getSubProperty()); // 输出sub
     console.log(`superProperty:${instance.subProperty}`); // 输出super，说明子类实例对象中存在superProperty
     // console.log('getSuperProperty:' + instance.getSuperProperty()); 报错，无法访问父类原型中定义的方法
     
     console.log(instance);
     // 输出结果显示该实例对象含有subProperty和superProperty两个属性，但是其原型对象是Object
     ```
   
     由此可以总结出盗用构造函数实现继承的特点。
   
     - **直接继承父类构造函数中定义的属性，并内化成自己的属性**，解决了修改引用值属性导致的属性污染问题。
   
     - 子类的构造函数中盗用了父类的构造函数，使得**子类实例化时可以访问父类构造函数**，也就可以给父类构造函数传参。

     - **没有对子类的原型对象进行修改操作，因此子类的原型还是`Object`，子类实例也就无法访问父类原型对象定义的方法了**。

       

   - ##### 组合继承（原型链+盗用构造函数）
   
     > **怎么实现？**
   
     结合使用**原型链继承来继承父类方法，盗用构造函数来继承父类属性**。
     
     ```javascript
     // 父类构造函数
     function SuperType(superPro){
       this.superProperty = superPro;
       this.colors = ['black','red'];
     }
     
     // 父类原型对象上的方法
     SuperType.prototype.getSuperProperty = function() {
       return this.superProperty;
     }
     
     // 子类构造函数
     function SubType(subPro){
         // **继承父类的属性
       SuperType.call(this, 'super');
       this.subProperty = subPro;
     }
     
     // **继承父类方法
     SubType.prototype = new SuperType();
     ```
     
     
     
   - ##### 原型式继承
   
     > **怎么实现？**
   
     两种方式如下：
     
     ```javascript
     let animal = {
       name:'pig',
       friends: ['dog','cat'],
       location: 'forest',
     }
     
     // **1. 创建一个临时构造函数，把作为传参的对象当作该临时构造函数的原型对象，返回这个临时构造函数的实例
     function object(obj){
       function f(){};
       f.prototype = obj;
       return new f();
     }
     let anotherAnimal = object(animal);
     
     // **2. ES5通过Object.create()对原型式继承进行了规范化，但他们的作用是一样的，即将传参对象作为新建对象的原型对象
     let anotherAnimal2 = Object.create(animal);
     // 可以定义或覆盖属性
     let anotherAnimal3 = Object.create(animal， {
                                        name: {
                                       	value: 'cat', 
                                        }
                                       });
     ```
     
     原型式继承适用于**不自定义类型（即不自定义构造函数），通过原型的方式来实现对象之间的信息共享**的情况。
     
     和原型链继承相同的是，原型式继承把一个实例对象作为另一个对象的原型对象，可以继承该对象的属性和方法，
     
     但是同样会有“牵一发而动全身”的情况，即原型对象中的引用值属性一旦被修改，就会污染所有实例对象的属性值。
   
   
   
   - ##### 寄生式继承
   
     > **怎么实现？**
   
     **在原型式继承的基础上，对创建的新对象进行增强后返回**。
   
     ```javascript
     function createAnimal(origin) {
       let clone = Object.create(origin);
       // 增强对象
       clone.eatable = true;
       return clone;
     }
     ```
   
     寄生式继承基于原型式继承的方式、构造函数创建对象的思路，因此它**同样适用于不关注类型和构造函数、而更关注对象的信息共享的情况**。
   
     它的缺点也很明显，和构造函数创建对象一样会导致对象里的函数难以重用，和原型式继承一样会污染引用值属性。
   
     
   
   - ##### 寄生式组合继承
   
     > **为什么要使用寄生式组合继承？**
     
     **为了减少调用父类构造函数产生的开销**。
     
     这个开销有两方面：第一，用组合继承来实现继承时，**会调用两次父类的构造方法**；第二，调用父类构造函数来创建实例对象作为子类原型对象时，**这个原型对象的属性实际上是不必要的**，因为我们已经用盗用构造函数来继承了父类的属性了。
     
     > **怎么实现？**
     
     寄生式组合继承的**核心**就在于**用寄生式继承的方式来继承父类的方法**，而不是用创建父类实例对象的方式，这样就只会在继承属性时调用一次父类的构造函数，也不会在原型对象上产生多余的属性，同时还保留了原型链。
     
     ```js
     // **继承父类方法
     
     // 组合式继承：调用父类构造函数，创建一个实例对象来当作子类的原型对象
     SubType.prototype = new SuperType();
     
     // 寄生式继承：
     let prototype = Object.create(SuperType.prototype);
     prototype.constructor = SubType();
     SubType.prototype = prototype;
     ```
     
     
     
   - **ES6：`extends`关键字**
   
     > **使用`extends`时，父类可以是什么？**
   
     `extends`不仅可以继承一个类，还能继承一个单独的构造函数。这是因为`extends`本**质上可以继承任何含有构造函数（`[[construct]]`）和原型的对象**。
   
     > **`extends`关键字继承了父类的什么？**
   
     同样是继承父类的属性和方法。
   
     但是要明白，**ES6中类的定义能很有效地分割原型对象和实例对象**。这是因为类块中定义的方法都会被当作原型对象上的方法，而类中用`this`关键字声明的属性又都属于不同的实例对象。
   
     > **使用ES6的`extends`关键字和使用ES5的其他方法来实现继承有什么不同？**
   
     （1）首先要明白，ES6的`extends`其实是一个语法糖，其背后依然是原型链。
   
     （2）ES5实现继承虽然方法各异，但是都是直接处理构造函数和`prototype`对象；而`extends`可以避免我们直接操作这二者。
   
     （3）使用`extends`继承父类后，子类可以通过`super`关键字来访问父类的构造函数和静态方法。当子类没有显式定义自己的构造函数时，会默认继承父类的构造函数；若显式定义了构造函数，则必须引用`super()`或返回一个对象。



## 作用域

1. #### 什么是作用域（`scope`）？

   作用域可以从字面理解为**变量能够产生作用的区域**。

   我们要知道变量能够产生作用的两种方式是：

   `LHS`查询（赋值查询，要找到变量本身）和`RHS`查询（取值查询，只关心变量的源值）。

   因此作用域其实就是**可以帮助引擎确定在哪里查询、怎么查询变量的一套规则**，也就是说它**管理着变量的可访问性**。

   作用域包括三种：**全局作用域、函数作用域、块级作用域**。

   

2. #### 作用域和上下文有什么区别？

   > **（1） 什么是执行上下文？**

   上下文可以理解为**代码执行流所处的当前环境**。

   以函数举例，当**调用**函数时，代码执行流会进入该函数，此时会为这个函数调用**创建一个执行上下文**，并把这个上下文推进上下文栈上，表示当前代码执行流正处于此上下文的环境中。而函数执行完毕后，上下文就会被摧毁，因为代码执行流已经离开了这个函数，环境也就不需要存在了。

   每个上下文都会与一个**变量对象**相关联，**变量对象中保存着当前上下文可以访问的变量和函数**。因为代码的执行一定会涉及对变量的操作，所以上下文一定会和一个变量对象捆绑。这里的变量对象可以看作作用域在上下文中的体现。

   > **（2）作用域和上下文有什么区别？**

   - **意义不同**，作用域关注对变量要在哪里查询、怎么查询，而上下文关注的是代码执行流，随着代码的执行而生成、销毁。

   - **创建时间不同**，作用域在定义时被确定，而上下文在实行时才被确定。JavaScript采用的是词法作用域规则，也就是说代码写在哪里，作用域就在哪里生成，但是上下文明显并不是由写代码确定的。以函数举例，函数作用域会在声明函数时被创建，但是函数上下文是在函数被调用时才会创建。

   - **可变性不同**，作用域一般会保持不变，而执行上下文会随着代码执行流变化而变化。

     

3. #### 什么是作用域链？

   **作用域链是一个包含指针的列表，每个指针指向一个上下文中的变量对象**，这也间接说明了为什么可以把变量对象看成作用域的体现。

   **上下文中的代码在执行时，会创建一个作用域链**，而作用域链的**作用**就是**决定各级上下文访问变量和函数的顺序**，简单来说就是查询某个变量时应该遵循什么样的查询顺序。

   当代码执行流需要一个变量时，就会**沿着作用域链规定的查询顺序查询**，这个查询顺序是沿着作用域链**从前往后**的，因此当前上下文的变量对象永远在作用域链的最前端，全局上下文的变量对象永远在最尾端，即要查找某个变量，先从当前变量对象开始找，找不到就继续往后找，直到全局上下文中的变量对象。

   在函数中，作用域链体现在函数的`[[Scopes]]`特性里。需要注意的是，在声明函数时`[[Scopes]]`就会被创建，并预装载全局变量对象，在调用函数时再通过复制`[[Scopes]]`来创建作用域链。



## 函数

### `this`

1. #### `this`的指向规则

   - **箭头函数**

     箭头函数的`this`指向的是**声明函数时的上下文**

   - **默认规则**

     普通函数的`this`指向把函数当成方法来调用的**执行上下文**。

     但是要注意，** `this`是函数的内部对象**，不能再向内传递，因此当存在闭包时，闭包的携带作用域里是不会存在上级作用域的`this`对象的。

     ```js
     var name = 'window';
     let a = {
       name: 'Jhon',
       getName: function(){
         console.log(this.name); // Jhon
         return function(){
           console.log(this.name); // window
         }
       }
     }
     a.getName()();
     ```
   
   - **bind**

     利用`bind`修改函数的`this`指向，要注意调用`bind()`返回的是一个函数。
   
     ```js
     function b(){
       console.log(this);
     }
     // 第一种方式
     var c = b.bind(a);
     c();
     // 第二种方式
     b.bind(a)();
     ```
   
   - **apply/call**
   
     利用`apply`或`call`也可以修改函数`this`的指向，修改后会直接调用，但是不会影响到调用原函数时的`this`对象。
   
     ```js
     function b(){
       console.log(this);
     }
     b.apply(2); // 2
     b(); // window
     ```
   
   - **new**
   
     箭头函数之外的函数都可以作为`new`关键字的构造函数，此时函数中的`this`一定是创建的新对象。
   
   **注意**：
   
   1. 当应用多条绑定规则时，优先级是**：`new` > `bind` > `apply/call` > 默认规则**
   2. 注意函数名只是指向函数的指针
   3. 一定要留意函数的执行上下文对`this`指向的影响
   4. 注意全局对象上的方法（比如`setTimeout`）的回调方法的`this`指向的是全局对象
   5. 如果把`null`或`undefined`或空传入 `bind` 或 `apply/call` 方法中，相当于把`this`指向全局对象

### 闭包

1. #### 谈谈对闭包的理解。

   **闭包是指能够访问外部函数作用域，引用了外部变量的函数。**

   既然引用了外部函数的变量，那么闭包就相当于携带了一个外部函数的作用域。这个被携带函数在执行完毕后，其执行上下文会被销毁，但是活动对象（变量对象）会被保留下来。因为闭包被调用时，其作用域链包括了对外部函数的变量对象的引用，所以只有闭包被销毁后，被携带函数的变量对象才会被释放。

   闭包的作用是：**可以保护函数的私有变量（定义在函数或块中的变量）**。
   
   但是闭包因为会携带其他函数的作用域，所以会占用更多的内存，不能过度使用闭包。



## 深浅拷贝

1. #### 什么是深拷贝和浅拷贝？浅拷贝和赋值有什么区别？

   **浅拷贝**：创建一个新对象，其**拷贝了原对象的第一层引用**。即当原对象的属性值是**基本数据类型**时，**直接拷贝其值**；当原对象的属性值是**对象**时，将**拷贝指向该对象的指针**作为属性值。

   因此，拷贝后对象若改变类型为引用值的属性值，会影响到原对象。

   浅拷贝和赋值的区别在于，对对象的赋值并不会创建一个新对象，其规则等同变量复制。

   <img src="C:\Users\胖可丁\AppData\Roaming\Typora\typora-user-images\image-20210819094005471.png" alt="image-20210819094005471" style="zoom: 67%;" />

   **深拷贝**：**创建一个新对象，将原对象从内存中完整地拷贝一份出来。拷贝后对象不会对原对象造成影响。**

   <img src="C:\Users\胖可丁\AppData\Roaming\Typora\typora-user-images\image-20210819094557482.png" alt="image-20210819094557482" style="zoom:67%;" />

   

2. #### 怎么实现浅拷贝？

   - **Object.assign()**

     `Object.assign()`可以把任意多个源对象的可枚举属性值拷贝给目标对象，并返回拷贝后的目标对象。

     其原理相当于以下代码：

     ```js
     function shallowCopy(target, source) {
       for (let key in source) {
         target[key] = source[key];
       }
       return target;
     }
     ```

   - **扩展运算符**

     利用扩展运算符实现浅拷贝时，可以取出参数对象的可枚举属性值拷贝给目标对象。

     ```js
     let source = {};
     let target = {...source};
     ```

   - **数组方法：Array.slice()和Array.concat()**

     当调用`slice()`和`concat()`而不传参时，相当于对数组进行浅拷贝。

     

3. #### 怎么实现深拷贝？

   - **JSON.parse(JSON.stringify(obj))**

     可以用JSON方法实现深拷贝，但是JSON并不支持JavaScript的所有类型，也无法解决循环引用问题。

   - 自己实现深拷贝方法

     ```js
     function deepCopy(source, map = new WeakMap()) {
       // 1. 对源对象进行类型判断，从而确定返回的拷贝后对象的类型
       if (source instanceof Object) {
         // 2. 解决循环引用导致的爆栈问题，如果map中已有该属性对象，则无需再遍历
         if (map.has(source)) return map.get(source);
         else if (source instanceof Array) {
           target = [];
         } else if (source instanceof Function) {
           return function () {
             return source.apply(this, arguments)
           };
         } else if (source instanceof RegExp) {
           // 拼接正则
           return new RegExp(source.source, source.flags);
         } else if (source instanceof Date) {
           return new Date(source);
         } else {
           target = {}
           // 用map保存遍历过的属性对象
           map.set(source, target);
           for (let key in source) {
             target[key] = deepCopy(source[key], map);
           }
         }
         return target;
       } else return source;
     }
     ```

     

## 事件

1. #### 什么是宏任务和微任务？

   - 宏任务是由宿主发起的任务，包括：**script（外层同步代码）、`window.setTimeout()`、`window.setInternal()`、`window.requestAnimationFrame()`（要求浏览器在下次重绘之前调用指定的回调函数更新动画）、`setImmediate ()`（Node.js）**，最常见的是script和定时器。

   - 微任务是由JavaScript引擎发起的任务，包括：**Promise状态改变后的回调函数、MutationObserver（监视DOM树的变化，变化时调用回调函数）**等等，最常见的微任务是Promise状态改变后的回调函数。

     微任务**产生于宏任务的执行期间，只有在当前JS执行栈为空时才会执行微任务。**

     **当前宏任务产生的微任务永远先于下一个宏任务前执行**，执行微任务期间，当前宏任务并未完全结束。

   > 举个例子：小明去银行办理业务，叫号轮到小明时，柜员开始为小明办理他的主要业务（宏任务），主要业务办理完毕后（执行栈为空），柜员询问小明是否还有其他业务需要办理（查询微任务队列是否有微任务），柜员为小明办理其他业务（微任务），全部办理完毕后才会轮到下一位叫号（下一宏任务）。

   

2. #### 什么是事件循环(event loop)？

   event loop是JavaScript执行机制中的一环，它的作用在于调控执行机制，**确定下一个需要执行的任务**。

   它的每一次循环称为一次`tick`，**循环过程**如下：

   - 当前宏任务执行完毕后，若执行栈为空，判断微任务队列中是否存在需要执行的微任务
   - 执行所有微任务
   - 如果宿主为浏览器，判断是否有必要渲染页面
   - 执行下一个宏任务，开始新一轮`tick`

   要注意，真正执行任务的是JavaScript的主线程执行栈，event loop只是起到一个发号施令的作用。

   <img src="C:\Users\胖可丁\AppData\Roaming\Typora\typora-user-images\image-20210830221237291.png" alt="image-20210830221237291" style="zoom:67%;" />

   

3. #### JavaScript的执行机制是什么？

   1. **JavaScript引擎是单线程的，同一时间段只能执行一个任务**。

      而**浏览器是多线程的**，其主要线程包括：

      - **GUI渲染线程**

        负责渲染页面，解析HTML、CSS，构建DOM树，绘制页面等等；

        页面重绘和回流；

        与JS引擎互斥，即JS执行时会阻塞页面更新。

      - **JS引擎线程**

        是JavaScript的内核，负责JavaScript代码的执行

      - **事件触发线程（event table)**

        用于控制事件循环，管理任务队列；

        **当遇到事件绑定或者异步操作时，事件触发线程会将它们添加到对应的线程中进行处理，有了处理结果以后，事件触发线程会将回调函数添加到任务队列，等待JS引擎线程处理**；

        事件触发线程并不执行任务，只是负责跟踪任务，并及时将它们推进任务队列。

      - **定时器线程**
        `setTimeout()`和`setInterval()`所处的线程就是定时器线程，由于JavaScript引擎线程是单线程的，所以需要单独线程来计时并触发定时。

      - **异步http请求线程**

        负责执行异步请求。

   2. 首先，最外层的script会作为第一个宏任务开始执行。

      当遇到同步代码时，推入主线程执行栈执行；遇到异步代码时，判断其属于宏任务还是微任务；

      将异步任务推给事件触发线程(event table)，即在主线程内，这些任务属于被挂起的状态，而在事件触发线程内，宏任务会被推进相应线程处理，并注册回调函数，微任务直接注册回调函数；

      异步任务有了处理结果后，事件触发线程会将它们推进任务队列(event quene)，宏任务推进宏任务队列(tasks quene)，微任务推进微任务队列(microtasks quene)；

      第一个宏任务执行完毕后，会进入事件循环(event loop)，JS引擎会执行事件循环指示的任务，直到执行栈和所有队列都为空。
      
      

4. #### 什么是事件冒泡和事件捕获？

   **事件流描述了页面接收事件的顺序**，IE和Netscape提出了两种完全相反的事件流模型，分别是事件冒泡和事件捕获。

   - **事件冒泡**：事件被定义为由最具体的那个元素触发，逐级向上传播至没有那么具体的元素（文档）。现代浏览器都支持事件冒泡，且事件会一直冒泡到window对象。
   - **事件捕获**：最不具体的节点最先收到事件，而最具体的节点最后收到事件。事件捕获是为了在事件到达最终目标之前拦截事件。

   DOM2规范中规定了**事件流包括三个阶段：事件捕获、到达目标和事件冒泡**。

   DOM2的事件处理程序方法` element.addEventListener(event, function, useCapture)`的第三个参数`useCapture`是一个布尔值，为`true`时表示在捕获阶段调用事件处理程序，为`false`时表示在冒泡阶段调用事件处理程序，默认值为`false`.

   

5. #### 什么是事件委托（事件代理）？

   1. 事件对象是能够传给事件处理程序的唯一参数，其常见的属性和方法包括：`type`(返回被触发事件类型的字符串)，`target`(事件目标)、`currentTarget`(当前事件处理程序的所在元素)、`stopPropagation()`(阻止事件冒泡)、`preventDefault()`(阻止默认事件)等。
   2. 事件委托的原理：**不是给每个子节点都设置事件监听器，而是给父节点设置事件监听器，利用冒泡原理影响每个子节点。**
   3. 使用事件委托可以减少事件处理函数来做到性能优化，在事件处理函数中要善用事件对象的各个属性和方法。
